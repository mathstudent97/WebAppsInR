#####################################

# Building an ML / Data-Driven       # 
#Web Application in R               #

# This will make use of the random  #
#forest algorithm. It aims to       #
#predict whether or not to play     #
#golf as a function of the input    #
#weather parameters.                #

# Check out uploaded pdf for more   #
#info:                              #


# Used this as reference: http://youtube.com/dataprofessor #

#####################################

library(shiny)
library(shinythemes)
library(data.table)
library(RCurl)
library(randomForest)


# Read the data; create data object 
weather <- read.csv(text = getURL("https://raw.githubusercontent.com/dataprofessor/data/master/weather-weka.csv"))


# Build mordel to make a prediction
model <- randomForest(play ~ ., data = weather, ntree = 500, mtry = 4, importance = TRUE)

# Save model to RDS file
# saveRDS(model, "model.rds")

# Read in the RF model
# model <- readRDS("model.rds")


###########################
##### User Interfrace #####
###########################


# Define UI for app
# recall this is the first component of the shinyweb app 

ui <- fluidPage(theme = shinytheme("superhero"),

    # Page header
    headerPanel('To play golf? OR To not play golf?'),
    # headerPanel('Play Golf?'),

    # Input values
    sidebarPanel(
        HTML("<h3>Weather Parameters</h3>"),
        #HTML("<h3>Input Parameters</h3>"),
        
        selectInput("outlook", label = "Outlook:",
                    choices = list("Sunny" = "sunny", "Overcast" = "overcast", "Rainy" = "rainy"),
                    selected = "Rainy"),
        # "choices" part provides the equivalences of values from the actual data set
        # recall: "selected" is the default value that appears on app
        # "Outlook" is one of the four variables, with 3 choices (sunny, overcast, rainy)
            # those capitalized, are what appear on the app; I'll include "label = " so it is
            #easier to read
        # "selectInput" is a drop down menu
        # the "label" argument is not really needed; optional (line#60)(label = "Outlook:")
        sliderInput("temperature", "Temperature:",
                    min = 64, max = 86,
                    value = 70),
        # "Temp" is another variable
        sliderInput("humidity", "Humidity:",
                    min = 65, max = 96,
                    value = 90),
        # "Humidity" is another variable
        selectInput("windy", label = "Windy:",
                    choices = list("Yes" = "TRUE", "No" = "FALSE"),
                    selected = "TRUE"),
        # "Windy" is another variable
        
        # keep note of all 4 of these variables, as these will be used in the server fcn.
        # respectively, each will be referred to as input$...
        #around lines 107-110
        
        actionButton("submitbutton", "Submit", class = "btn btn-primary")
    ), # when ready to make a prediction, click on the "Submit" button
       # this submit button is added in order to overcome the reactive fcn
       #so, instead of a spontaneous result/ prediction, a prediction won't
       #be made until the user clicks on "Submit" button
    
    mainPanel(
        tags$label(h3('Status/Output/Prediction')), # Status/Output Text Box
        verbatimTextOutput('contents'),
        tableOutput('tabledata') # Prediction / results table
    )
    # "tabledata" will be displayed as a table ("tableOutput")
    # statust of the prediction "contents" will be displayed by "verbatimTextOutput" fcn.
    # "tags$label..." is pretty much just the title/ label that appears above the output
    #"h3" is just the font size; can reduce to h2 for bigger font; recall HTML...
 ) 

# the "mainPanel()" will display the result from the output generated
#from the server function
# the output being generated by the server component will be called "'contents'"
#and "'tabledata'"


##################
##### Server #####
##################

# Define server; the logic
# recall this is the 2nd component

server <- function(input, output, session) {
    
    # Input data
    datasetInput <- reactive({
        # "datasetInput" variable will comprise of the first component;
        #it will create a data frame comprising of the 4 values below:
        # outlook, temp, humidity, wind, play
        df <- data.frame(
            Name = c("outlook",
                     "temperature",
                     "humidity",
                     "windy"),
            Value = as.character(c(input$outlook,
                                   input$temperature,
                                   input$humidity,
                                   input$windy)),
            stringsAsFactors = FALSE)
        
        play <- "play"

        df <- rbind(df, play)
        # now, it will combine it with the "play" variable;
        #which is the 5th column of the original dataset
        
        input <- transpose(df)
        # and it will trnaspose the dataset; it will rotate it
        write.table(input, "input.csv", sep=",", quote = FALSE, row.names = FALSE, col.names = FALSE)
        # will write an "input.csv" file 
        test <- read.csv(paste("input", ".csv", sep = ""), header = TRUE)
        # to test & see, will apply model to input file
        # will put the data into this variable, "test"
        
        test$outlook <- factor(test$outlook, levels = c("overcast", "rainy", "sunny"))
        # will use above lines of code to test if it is working properly (applied the "factor" fcn.)
        #in order to tell that outlook has 3 levels
        # will assign the factor/ variable "outlook"
        # the input file only has "sunny" as a choice, so add the three above
        
        Output <- data.frame(Prediction=predict(model, test), round(predict(model, test, type="prob"), 3))
        print(Output)
        
                             
    })
    
    # Status/Output Text Box
    output$contents <- renderPrint({
        if (input$submitbutton > 0) {
            isolate("Calculation complete.")
        } else {
            return("Server is ready for calculation.")
        }
    })
    
    # finally, a prediction will be made using the model generated earlier
    #by means of the random forest algorithm 
    #and apply the prediction model to predict the input values from the user
    
    
    # Prediction results table
    output$tabledata <- renderTable({
        if (input$submitbutton > 0) {
            isolate(datasetInput())
        }
    })
    #and once the prediction is made, it will be sent here into 
    #"output$tabledata" as the function dataset input
    # then it is going to render the table as we will see in the web app
    
}   # NOTE:  there are 2 outputs being generated:
    # 1. output$content
    # 2. output$tabledata
#so, these two outputs will be sent to the UI component "mainPanel" (around line 93)


# Run the application 
# recall this is the 3rd component; fusion of the ui and server
#components
shinyApp(ui = ui, server = server)
